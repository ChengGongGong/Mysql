# 1. 数据分片
    将大数据表分解为较小的表（称为分片）的过程，这些分片分布在多个数据库集群节点上，
    每个分片上包含原有总数据集的一个子集，可以将总负载分散在各个分区之上。
    
    1. 方式：
      1. 水平分片：在不同的数据库节点中存储同一表的不同行。
      2. 垂直分片：在不同的数据库节点中存储表不同的表列。
    2. 分片算法(指代水平分片所需要的算法)：
      
      1. 哈希分片：首先需要获取分片键，然后根据特定的哈希算法计算它的哈希值，最后使用哈希值确定数据应被放置在哪个分片中。
        适合随机读写的场景，很好地分散系统负载，但是不利于范围扫描查询操作。
      2. 范围分片：根据数据值或键空间的范围对数据进行划分，相邻的分片键更有可能落入相同的分片上。
        需要选择合适的分片键，这些分片键需要尽量不包含重复数值，也就是其候选数值尽可能地离散，同时数据不要单调递增或递减。
      3. 地理位置算法
        一般用于 NewSQL 数据库，提供全球范围内分布数据的能力，数据被映射到特定的分片，而这些分片又被映射到特定区域以及这些区域中的节点。
        然后在给定区域内，使用哈希或范围分片对数据进行分片。
      4. 融合算法
        建立一个多级分片策略，该策略在最上层使用哈希算法，而在每个基于哈希的分片单元中，数据将按顺序存储。
    3. 手动分片
      设置静态规则来将数据根据分片算法分散到数据库节点，一般是由于用户使用的数据库不支持自动的分片；
      可以在应用层面上做数据分片来解决，也可以使用简单的数据库中间件或 Proxy 来设置静态的分片规则来解决。
      缺点：
        数据分布不均匀，数据分布不均可能导致数据库负载极其不平衡
 # 2. 数据复制
      在几个不同的数据库节点上保留相同数据的副本，从而提供一种数据冗余。这份冗余的数据可以提高数据查询性能，而更重要的是保证数据库的可用性。
      
## 2.1. 单主复制：主从复制
      客户要写入数据库时，必须将请求发送给主节点，而后主节点将这些数据转换为复制日志或修改数据流发送给其所有从节点。
      
      1. 复制同步模式：同步复制、半同步复制、异步复制(不管从库的复制情况如何，主库可以写入该数据。而此时，如果主库失效，那么还未同步到从库的数据就会丢失)；
      2. 复制延迟：同步复制时，每次写入都需要同步所有从节点，会造成一部分从节点已经有数据，但是主节点还没写入数据；而异步复制的问题是从节点的数据可能不是最新的；
      3. 复制与高可用性：从节点故障、主节点故障
      4. 复制方式：基于语句的复制、日志(WAL)同步、行复制、ETL工具
## 2.2. 多主复制：主主复制
      数据库集群内存在多个对等的主节点，它们可以同时接受写入，每个主节点同时充当主节点的从节点。
      优点：
          1. 获得更好的写入性能：使数据可以就近写入；
          2. 数据中心级别的高可用：每个数据中心可以独立于其他数据中心继续运行；
          3. 更好的数据访问性能：用户可以访问到距离他最近的数据中心。
       缺点：
          1. 存在一种可能性，即两个不同的主节点同时修改相同的数据。
          2. 处理客户端离线操作的一致性问题
## 2.3. MySQL复制技术的发展
    1. 传统复制，主从高可用，适用场景：MySQL 的版本≤5.5;只用于异步复制且一主多从环境；基于传统复制的高可用
    2. 半同步复制
      1. binlog 使用半同步，而第一代是异步同步，它保障了数据安全，一般至少要同步两个节点；
      2. 保留异步复制，保障了复制性能，通过监控复制的延迟；
      3. 引入配置中心，对外提供健康的 MySQL 服务；
      4. 需要支持跨 IDC 复制。需要引入监控 Monitor，配合 consul 注册中心；
      
        问题：
          1. 存在幻读的情况。当事务同步到从库但没有 ACK 时，主库发生宕机；此时主库没有该事务，而从库有。
          2. MySQL 5.6 本身半同步 ACK 确认在 dump_thread 中，dump_thread 存在 IO 瓶颈问题。
     3. 增强半同步复制
        1. 主从的复制都是用独立的线程来运行；
        2. 主库采用 binlog group commit，也就是组提交来提供数据库的写入性能；
        3. 从库采用并行复制，它是基于事务的，通过数据参数调整线程数量来提高性能
        问题：
          幽灵事务：数据写入 binlog 后，主库掉电。
          由于故障恢复流程需要从 binlog 中恢复，那么这份数据就在主库。
          但是如果它没有被同步到从库，就会造成从库不能切换为主库，只能去尝试恢复原崩溃的主库
     4. MySQL 组复制
        1. 支持多主复制，同时保留单主复制的功能。
        2. 组复制的多主技术需要 Paxos 算法深度参与，并去决定每一次数据的写入，解决写入冲突。
        优点：
          1. 高可用分片：：数据库节点动态添加和移除。分片实现写扩展，每个分片是一个复制组。
          2. 自动化故障检测与容错：如果一个节点无法响应，组内大多数成员认为该节点已不正常，则自动隔离；
          3. 方案完整
     5. 注，无主复制技术
        1. 所有的副本都支持直接接受客户端的请求，客户端直接对多副本统一进行写操作，由一个类似代理节点，帮助客户端进行统一的写操作
        2. 节点失效时写入数据：
            1. 读修复，在客户端进行数据读取的时候，会从多个副本获取数据，可以通过时间戳标志的方式来判断最新数据，对存在旧数据的节点发送数据更新的请求；
            2. 反熵处理，用定期执行的后台进程扫描各个节点的差异数据，但是需要按照版本号比较大量数据并进行更新操作，数据更新有较大的延时；
        3. 读写确认
            如果有n个节点，w个法定票数（判定是否写入成功），读取至少需要r个节点，则只要 w + r > n 则读取到的数据必然包含最新值；
            w<n时，写操作允许节点不可用；
            r<n时，读操作允许节点不可用；
            对于w+r>n的情况，允许最多w+r-n个节点不可用；
            出现的问题：
                1. 并发写入时发生冲突，如果按照最后写入获胜的话可能会丢失数据；
                2. 读写操作并发进行时不保证读到最新数据；
                3. 写入操作失败时可能需要多个节点进行数据回滚操作；
         4. 客户端有时无法与所有数据节点连接，这是处理读写操作时有两种策略：
            1. 由于无法连接所有节点，当无法达到w或者r节点要求时报错；
            2. 接受写操作，无法达到w和r要求时写到其他数据节点上
